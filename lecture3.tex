%! TEX root = lecture3_note.tex
\title{Lambda Calculus and Types, 3}
\subtitle{Polymorphic Lambda Calculus}
\begin{document}
\begin{frame}
\maketitle
\end{frame}

In the second lecture, we have seen that the type $\nat \defeq (\tau \to \tau)
\to \tau \to \tau$ of natural numbers is not a single type but a
\emph{collection} of types for each type~$\tau$. This intriguing formulation, in
fact, shows us how to make $\nat$ a single type: we simply internalise the
universal quantifier in our type system. That is, we push the universal
quantifier 
\begin{quote}
``For all type $\tau$, ...''
\end{quote}
in the metalanguage into our system:
\[
  \forall t.\, \sigma(t)
\]
where $\tau$ is a \emph{type variable}. For example, the type of natural numbers
can be defined as a single type:
\[
  \nat \defeq \forall t.\, (t \to t) \to t \to t
\]
and the type $\nat_\tau = (\tau \to \tau) \to \tau \to \tau$ becomes an instance
of $\nat$ with $t$ substituted by~$\tau$.  Simply
typed lambda calculus extended with this universal type constructor is called
\emph{System F} introduced by Girard and also called \emph{polymorphic lambda
  calculus}.

\section{Syntax and typing rules}
We now present polymorphic lambda calculus \emph{\'a la} Church. For simplicity,
we do not treat the Curry-style variant. 
\begin{definition}
  Given type variables~$\mathbb{V}$, the set $\type$ of \emph{types} is
  inductively defined by
  \begin{multicols}{3}
    \begin{prooftree}
      \AXC{$t \in \mathbb{V}$}
      \UIC{$t \in \type$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$\sigma \in \type$}
      \AXC{$\tau   \in \type$}
      \BIC{$\sigma \to \tau \in \type$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$\sigma \in \type$}
      \AXC{$t   \in \mathbb{V}$}
      \RightLabel{(poly)}
      \BIC{$\forall t.\, \sigma \in \type$}
    \end{prooftree}
  \end{multicols}
\end{definition}
As we have defined what the set of  free variables of a $\lambda$-term is, a
similar definition also extends to types:
\begin{definition}
  The \emph{free variable} $\FV\colon \type \to \mathcal{P}\mathbb{V}$ of a type
  is a function mapping a type to a set of type variables defined by
  \begin{align*}
    \FV(t) & {} = t \\
    \FV(\sigma \to \tau) & {} = \FV(\sigma) \cup \FV(\tau) \\
    \FV(\forall t.\, \sigma) & {} = \FV(\sigma) - \{t\}
  \end{align*}
  For convenience, the function extends to contexts:
  \[
    \FV(\Gamma) = \set{ t \in \mathbb{V}}{ \exists (x : \sigma) \in \Gamma
      \wedge t \in \FV(\rho) }.
  \]
\end{definition}
\begin{example}
  Assume that $v$, $v_1$ and $v_2$ are type variables.
  \begin{enumerate}
    \item $\FV(t_1) = \{t_1\}$.
    \item $\FV(\forall t.\, (t \to t) \to t \to t) = \emptyset$.
    \item $\FV(x : t_1, y : t_2, z : \forall t.\,t)
      = \{t_1, t_2\}$.
  \end{enumerate}
\end{example}
Since the use of variable in a type is to be substituted by other types, we also
need to define \emph{substitution over types} accordingly and routinely.

\begin{definition}
  The \emph{(capture-avoidance) substitution} of a type $\rho$ for the free
  occurrence of a type variable~$t$ is defined inductively as 
  \begin{align*}
    t\subst{t}{\rho} & = \rho \\
    u\subst{t}{\rho} & = u && \text{if $u \neq t$}\\
    (\sigma\to\tau)\subst{t}{\rho} & =
    (\sigma\subst{t}{\rho})\to
    (\tau\subst{t}{\rho}) \\
    (\forall t.\sigma)\subst{t}{\rho} & = \forall v.\sigma \\
    (\forall u.\sigma)\subst{t}{\rho} & = \forall u.\sigma\subst{t}{\rho}
    && \text{if $u \neq t$ and $v \not\in \FV(\rho)$} 
  \end{align*}
\end{definition}

Now we proceed with terms in polymorphic lambda calculus. 

\begin{definition}
  Given a set~$V$ of variable, a set $\mathbb{V}$ of type variables, 
  the set~$\term$ of $\lambda$-terms is augmented with polymorphism
  and generated by the following grammar 
  \begin{multicols}{2}
    \begin{prooftree}
      \AXC{$x \in V$}
      \UIC{$x \in \term$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$M \in \term$}
      \AXC{$N \in \term$}
      \BIC{$(M\;N) \in \term$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$M \in \term$}
      \AXC{$x \in V$}
      \AXC{$\tau \in \type$}
      \TIC{$\lambda (x : \tau).\, M \in \term$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$M \in \term$}
      \AXC{$t \in \mathbb{V}$}
      \BIC{$\Lambda t.\; M \in \term$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$M \in \term$}
      \AXC{$\tau \in \type$}
      \BIC{$(M\;\tau) \in \term$}
    \end{prooftree}
  \end{multicols}
\end{definition}
\begin{example} \label{ex:f-terms}
  Can you see the untyped version of the following terms?
  \begin{enumerate}
    \item $\Lambda t.\,\lambda (x : t).\, x$
    \item $\Lambda t.\, \lambda (x : t)(y : t).\, x$
    \item $(\Lambda t.\, \lambda (x : t)(y : t).\, x)\;\sigma\;M\;N$
     where  $M, N$ are terms and $t$ a type variable..
    \item $\Lambda t.\, \lambda (f : t \to t)(x : t).\, f\;f\;x$
    \end{enumerate}
\end{example}

We also extend the typing rules of simply typed lambda calculus to introduce the
type polymorphism and to instantiate with a specific type:
\begin{definition}[Typing rules]
  The set of valid judgements in polymorphic lambda calculus is defined
  inductively as follows:
  \begin{multicols}{2} 
  \begin{prooftree}
    \AXC{$\phantom{\Gamma}$}
    \UIC{$\Gamma, x : \sigma \vdash x : \sigma$}
  \end{prooftree}
  \begin{prooftree}
    \AXC{$\Gamma \vdash M : (\sigma \to \tau)$}
    \AXC{$\Gamma \vdash N : \sigma$}
    \BIC{$\Gamma \vdash (M\;N) : \tau$}
  \end{prooftree}
  \begin{prooftree}
    \AXC{$\Gamma, x : \sigma \vdash M : \tau$}
    \UIC{$\Gamma \vdash \lambda (x : \sigma).\; M : (\sigma \to \tau)$}
  \end{prooftree}
  \begin{prooftree}
    \AXC{$\Gamma \vdash M : \sigma$}
    \AXC{$t \not\in \FV(\Gamma)$}
    \RightLabel{($\forall$-intro)}
    \BIC{$\Gamma \vdash \Lambda t.\;M : \forall v.\, \sigma$}
  \end{prooftree}
  \begin{prooftree}
    \AXC{$\Gamma \vdash M : \forall v.\, \sigma$}
    \RightLabel{($\forall$-elim)}
    \UIC{$\Gamma \vdash (M\;\tau) : \sigma\subst{v}{\tau}$}
  \end{prooftree}
  \end{multicols}
\end{definition}
\begin{example} \label{ex:f-welltyped}
  The following terms are well-typed:
  \begin{enumerate}
    \item ${}\vdash\Lambda t.\,\lambda (x : t).\, x : \forall t.\;t\to t$
    \item ${}\vdash\Lambda t.\, \lambda (x : t)(y : t).\, x : \forall t.\;t \to t \to t$
    \item $M : \sigma, N : \sigma
      \vdash (\Lambda t.\, \lambda (x : t)(y : t).\, x)\;\sigma\;M\;N
      : \sigma \to \sigma \to \sigma$
    \item ${}\vdash\Lambda t.\, \lambda (f : t \to t)(x : t).\, f\;f\;x : 
      \forall t.\;(t\to t) \to t\to t$
    \end{enumerate}
\end{example}
We derive the second one and leave others to the reader.
\begin{prooftree}
  \AXC{}
  \RightLabel{(var)}
  \UIC{$x : t, y : t \vdash x : t$}
  \UIC{$x : t \vdash \lambda (y : t).\; x : t \to t$}
  \UIC{$\vdash \lambda (x : t)(y : t).\; x : t \to t \to t$}
  \UIC{$\vdash \Lambda t.\,\lambda (x : t)(y : t).\; x :\forall t.\,t \to t \to
    t$}
\end{prooftree}

In line with the new syntax, we also need to extend \emph{substitution over
  terms} and \emph{$\beta$-reduction}. The substitution is rather routine and
left as an exercise to the reader.  The $\beta$-conversion has an additional
rule:
\[
  M\;\tau \xrightarrow{\beta} M
\]
and then we define the \emph{one-step} $\beta$-reduction similarly.

We can also erase the type information of well-typed terms and reduce it, as if
untyped. To be precise, we state the erasing map and the result without any
proof.
\begin{definition}
  The \emph{erasing map} is a function from typed terms in polymorphic lambda
  calculus to untyped terms in lambda calculus defined inductively 
  \begin{align*}
    |x| & = x \\
    |\lambda (x : \tau).\,M| & = \lambda x.\, |M| \\
    |(M\;N)| & = (|M|\;|N|) \\
    |\Lambda t.\, M| & = |M| \\
    |(M\;\tau)| & = |M|
  \end{align*}
\end{definition}
\begin{theorem}[Preservation Theorem]
  Within polymorphic lambda calculus, if ${}\vdash M : \sigma$ and $|M|
  \onereduce N$, then there exists some typed-term~$N$ with
  ${}\vdash N : \sigma$.
\end{theorem}
\subsection*{Exercise}
\begin{enumerate}
  \item Complete Example~\ref{ex:f-terms}.
  \item Derive every judgement in Example~\ref{ex:f-welltyped}.
\end{enumerate}
\section{Data types in System F}
Thanks to type polymorphism, the system can now express much more types,
including the \emph{product type}, the \emph{sum type}, the type of
\emph{natural number}, the type of \emph{lists}, and even every inductive data
type.
\subsection{Empty type}
The empty type is a type supposed to have no inhabitant, and it can be defined
as
\[
  \bot \defeq \forall t.\,t
\]
Note that if there is any term of this type~$\bot$, then we can infer that every
type has a term:
\begin{prooftree}
  \AXC{$\vdash M : \bot$}
  \UIC{$\vdash M\,\tau : \tau$}
\end{prooftree}
Can this be true? We will answer it later.
\subsection{Sum type}
The sum type of $\tau$ and $\sigma$ represents the
``disjoint union'' of two types, defined as
\[
  \sigma + \tau \defeq \forall t. (\sigma \to t) \to (\tau \to t) \to t
\]
with two ``injections'': The first injection is defined by
\begin{align*}
  \vdash {} & \mathtt{inj}_1 \colon \sigma \to \sigma + \tau \\
  & \mathtt{inj}_1 \defeq \lambda (x : \sigma).\;\Lambda t.\,\lambda (f :
  \sigma\to t)(g : \tau\to t).\, f\;x 
\end{align*}
and similarly the second injection
\begin{align*}
  \vdash {} & \mathtt{inj}_2 \colon \tau \to \sigma + \tau \\
  & \mathtt{inj}_2 \defeq ?
\end{align*}
(Find the exact definition of $\mathtt{inj}_2$.)

With the sum type, we can implement the usual construct \texttt{case}:
\[
  \vdash \mathtt{case} : \forall\,\rho.\;(\sigma \to \rho) \to (\tau \to \rho)
  \to (\sigma + \tau) \to \rho
\]
so that $\mathtt{case}\;F\;G$ returns a term of type $\rho$ a term with an input
of type $\sigma + \tau$, provided that $\vdash F : \sigma\to\rho$ and $\vdash G
: \tau \to \rho$. Try to find the exact definition of $\mathtt{case}$.
\subsection{Product type}
The product type can be defined as
\[
  \sigma \times \tau \defeq \forall t. (\sigma \to \tau \to t) \to t
\]
with the pairing function
\begin{align*}
  {} \vdash & \lambda (x : \sigma)(y : \tau).\; \left< x, y\right> :
  \sigma \to \tau \to \sigma
  \times \tau \\
  & \left< x, y\right> \defeq \Lambda t.\,\lambda (f : \sigma \to \tau \to t).\,
  f\;x\;y
\end{align*}
Try to define projections 
\[
  \mathtt{proj}_1 : \sigma \times \tau \to \sigma
  \quad\text{and}\quad
  \mathtt{proj}_2 : \sigma\times \tau \to \tau
\]
\subsection{Natural numbers}
Back to Church numerals, we can now define them with a single type:
\[
  \nat \defeq \forall t.\, (t\to t)\to t\to t
\]
  \begin{description}
    \item[Polymorphic Church numerals]
      \begin{align*}
        \vdash{} & \bc_n : \nat \\
        & \bc_n \defeq \Lambda t.\,\lambda (f:t \to t)\,(x:t).\,
        f^n\;x
      \end{align*}
    \item[Successor]
      \begin{align*}
        \vdash{} & \suc : \nat \to \nat \\
        & \suc \defeq \,\lambda (n : \nat).\,\Lambda t.\,\lambda
        (f : t \to t)\,(x:t)\,.\;f\;(n\;t\;f\;x) 
      \end{align*}
    \item[Addition]
      \begin{align*}
        \vdash{} & \add : \nat \to \nat \to \nat \\
        & \add \defeq \lambda (n : \nat)\,(m:\nat)\,\Lambda t.\,
        \lambda (f:t\to t)\,(x: t).\; (m\;t\;f)\;(n\;t\;f\;x) 
      \end{align*}
    \item[Multiplication] 
      \begin{align*}
      \vdash{} & \mul : \nat\to \nat \to\nat\\
        & \mul \defeq\,?
      \end{align*}
    \item[Conditional]
      \begin{align*}
        \vdash {} & \ifz : \forall t.\,\nat \to t \to t \to t \\
        & \ifz \defeq\,?
      \end{align*}
  \end{description}
However, polymorphic lambda calculus allows us to define a certain form of
recursion on Church numerals, called \emph{primitive recursion} or the
\texttt{fold} function which you have seen in Haskell.
\begin{align*}
  \vdash{} & \mathtt{fold} : \forall t.\, (t \to t) \to t \to \nat \to t  \\
  & \mathtt{fold} \defeq \Lambda t.\, \lambda (f : t \to t)(e : t)(n : \nat). 
  n\;t\;f\;e
\end{align*}
The addition, multiplication, and predecessor operations can be redefined as
follows:
\begin{example}
  Find the types of following terms and justify your answer.
  \begin{enumerate}
    \item $\pred \defeq \mathtt{fold}\;\nat\;(\lambda (f : \nat \to \nat)(x : \nat).\,
      x)\;\bc_0$
    \item $\add' \defeq \mathtt{fold}\;\nat\;\suc\;\bc_0$
  \end{enumerate}
  Moreover, show that each of them reduces to the expected Church numerals
  \begin{enumerate}
    \item $\pred\;\bc_0 \reduce \bc_0$ and $\pred\;\bc_{n+1}
      \reduce \bc_n$.
    \item $\add'\;\bc_n\;\bc_m \reduce \bc_{n+m}$.
  \end{enumerate}
\end{example}
\subsection{List}
Finally, the type of list over a type~$\sigma$ can also be defined in
polymorphic lambda calculus. It is similar to the type of natural numbers:
\[
  \List\,\sigma\defeq \forall t.\, t \to (\sigma \to t \to t) \to t 
\]
with ``list constructors'' 
\begin{enumerate}
  \item $\mathtt{nil}_\sigma \defeq \Lambda t.\lambda (h : t)(f :
    \sigma\to t \to t).\, h$
  \item $\mathtt{cons}_\sigma \defeq \lambda (x : \sigma)(xs : \List\,
    \sigma).\,\Lambda t.\lambda(h : t)(f : \sigma\to t \to t).f\,x\,(xs\; t\;
    h\; f)$ which has the type $\sigma \to \List\,\sigma \to  \List\,\sigma$.
  \end{enumerate}
\subsection*{Exercise}
\begin{enumerate}
  \item Define $\mathtt{fold}$ over the list type over~$\sigma$.
  \item Define $\mathtt{length}_{\sigma} : \List \sigma \to \nat$ calculating
    the length of a given list so that
    \[
      \mathtt{length}\;\mathtt{nil}_\sigma \reduce \bc_0
      \quad\text{and}\quad
      \mathtt{length}\;(\mathtt{cons}_\sigma\;x\;xs)
      \reduce \suc\;(\mathtt{length}\;xs) 
    \]
  \item The type of lists we just defined does depend on a specific
    type~$\sigma$ unnecessarily. Can you generalise it further as well as
    constructors?
  \end{enumerate}

%\section{Parametricity}
%The polymorphism in System F is \emph{parametric} in the sense that every
%instance is uniformly defined. To put it differently, it cannot depend on any
%specific type. It is different from the \emph{ad hoc} polymorphism adopted in
%most of programming languages like C++.
%
%Recall the type of polymorphic identity 
%\[
%  \forall t.\, t \to t
%\]
%where the input is some term~$M$ of type $t$. Since we have no idea about the $t$
%itself, the only thing we can return is~$M$ itself. It is provable that in
%System F the every term of that type reduces to the identity
%\[
%  \Lambda t.\,\lambda (x : t).\, x 
%\]
%
%In fact, Reynolds shows that every term in polymorphic lambda calculus satisfies
%certain equations without ``looking inside the term'' in \cite{Reynolds1983}
%(and also see \cite{Wadler1989}). Here, we will present a simplified statement.


\subsection*{Exercise}


\bibliographystyle{plain}
\bibliography{library} 
\end{document}
