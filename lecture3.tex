%! TEX root = lecture3_note.tex
\title{Lambda Calculus and Types, 3}
\subtitle{Polymorphic Lambda Calculus}
\begin{document}
\begin{frame}
\maketitle
\end{frame}

In the second lecture, we have seen that the type $\nat \defeq (\tau \to \tau)
\to \tau \to \tau$ of natural numbers is not a single type but a
\emph{collection} of types for each type~$\tau$. This intriguing formulation, in
fact, shows how to make $\nat$ a single type: we simply internalise the
universal quantifier in our type system. That is, we push the universal
quantifier 
\begin{quote}
``For all type $\tau$, ...''
\end{quote}
in the metalanguage into our system:
\[
  \forall v.\, \sigma(v)
\]
where $\tau$ is a \emph{type variable}. Therefore, the natural number type can
be defined as a \emph{single} type:
\[
  \nat \defeq \forall v.\, (v \to v) \to v \to v
\]
Each instance $\nat_\tau$ of $\nat$ is now written as $(\nat\;\tau)$.  Simply
typed lambda calculus extended with this universal type constructor is called
\emph{System F} introduced by Girard and also called \emph{polymorphic lambda
  calculus}.
\todo{find the reference}

\section{Syntax and typing rules}
We now present polymorphic lambda calculus \emph{\'a la} Church. For simplicity,
we do not treat the Curry-style variant. 
\begin{definition}
  Given type variables~$\mathbb{V}$, the set $\type$ of \emph{types} is
  inductively defined by
  \begin{multicols}{3}
    \begin{prooftree}
      \AXC{$v \in \mathbb{V}$}
      \UIC{$v \in \type$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$\sigma \in \type$}
      \AXC{$\tau   \in \type$}
      \BIC{$\sigma \to \tau \in \type$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$\sigma \in \type$}
      \AXC{$v   \in \mathbb{V}$}
      \RightLabel{(poly)}
      \BIC{$\forall v.\, \sigma \in \type$}
    \end{prooftree}
  \end{multicols}
\end{definition}
As we have defined what the set of  free variables of a $\lambda$-term is, a
similar definition also extends to types:
\begin{definition}
  The \emph{free variable} $\FV\colon \type \to \mathbb{V}$ of a type is a
  function inductively defined:
  \begin{align*}
    \FV(v) & {} = v \\
    \FV(\sigma \to \tau) & {} = \FV(\sigma) \cup \FV(\tau) \\
    \FV(\forall v.\, \sigma) & {} = \FV(\sigma) - \{v\}
  \end{align*}
  For convenience, the function extends to contexts:
  \[
    \FV(\Gamma) = \set{ v \in \mathbb{V}}{ \exists (x : \sigma) \in \Gamma
      \wedge v \in \FV(\rho) }.
  \]
\end{definition}
\begin{example}
  Assume that $v_1$ and $v_2$ are type variables.
  \begin{enumerate}
    \item $\FV(v_1) = \{v_1\}$.
    \item $\FV(\forall v.\, (v \to v) \to v \to v) = \emptyset$.
    \item $\FV(x : v_1, y : v_2, z : \forall v.\,v)
      = \{v_1, v_2\}$.
  \end{enumerate}
\end{example}
Since the use of variable in a type is to be substituted by other types, we also
need to define \emph{substitution over types} accordingly and routinely.

\begin{definition}
  The \emph{(capture-avoidance) substitution} of a type $\rho$ for the free occurrence of a
  variable~$v$ is defined inductively as 
  \begin{align*}
    v\subst{v}{\rho} & = \tau \\
    u\subst{v}{\rho} & = u && \text{if $u \neq v$}\\
    (\sigma\to\tau)\subst{v}{\rho} & =
    (\sigma\subst{v}{\rho})\to
    (\tau\subst{v}{\rho}) \\
    (\forall v.\sigma)\subst{v}{\rho} & = \forall v.\sigma \\
    (\forall u.\sigma)\subst{v}{\rho} & = \forall v.\sigma\subst{v}{\rho}
    && \text{if $u \neq v$ and $v \not\in \FV(\rho)$} 
  \end{align*}
\end{definition}

\begin{definition}
  Given a set~$V$ of variable, a set $\mathbb{V}$ of type variables, 
  the set~$\term$ of $\lambda$-terms is augmented with polymorphism
  and generated by the following grammar 
  \begin{multicols}{2}
    \begin{prooftree}
      \AXC{$x \in V$}
      \UIC{$x \in \term$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$M \in \term$}
      \AXC{$N \in \term$}
      \BIC{$(M\, N) \in \term$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$M \in \term$}
      \AXC{$x \in V$}
      \AXC{$\tau \in \type$}
      \TIC{$\lambda (x : \tau).\, M \in \term$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$M \in \term$}
      \AXC{$v \in \mathbb{V}$}
      \BIC{$\Lambda v.\, M \in \term$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$M \in \term$}
      \AXC{$\tau \in \type$}
      \BIC{$(M\, \tau) \in \term$}
    \end{prooftree}
  \end{multicols}
\end{definition}
\begin{example} \label{ex:f-terms}
  Can you guess the untyped version of the following terms?
  \begin{enumerate}
    \item $\Lambda v.\,\lambda (x : v).\, x$
    \item $\Lambda v.\, \lambda (x : v)(y : v).\, x$
    \item $\Lambda v.\, \lambda (f : v \to v)(x : v).\, f\;f\;x$
    \end{enumerate}
\end{example}

We also extend the typing rules of simply typed lambda calculus to introduce the
type polymorphism and to instantiate with a specific type:
\begin{definition}[Typing rules]
  The set of valid judgements in polymorphic lambda calculus is defined
  inductively as follows:
  \begin{multicols}{2} 
  \begin{prooftree}
    \AXC{}
    \UIC{$\Gamma, x : \sigma \vdash x : \sigma$}
  \end{prooftree}
  \begin{prooftree}
    \AXC{$\Gamma \vdash M : (\sigma \to \tau)$}
    \AXC{$\Gamma \vdash N : \sigma$}
    \BIC{$\Gamma \vdash (M\;N) : \tau$}
  \end{prooftree}
  \begin{prooftree}
    \AXC{$\Gamma, x : \sigma \vdash M : \tau$}
    \UIC{$\Gamma \vdash \lambda (x : \sigma).\; M : (\sigma \to \tau)$}
  \end{prooftree}
  \begin{prooftree}
    \AXC{$\Gamma \vdash M : \sigma$}
    \AXC{$v \not\in \FV(\Gamma)$}
    \RightLabel{($\forall$-intro)}
    \BIC{$\Gamma \vdash \Lambda v.\;M : \forall v.\, \sigma$}
  \end{prooftree}
  \begin{prooftree}
    \AXC{$\Gamma \vdash M : \forall v.\, \sigma$}
    \RightLabel{($\forall$-elim)}
    \UIC{$\Gamma \vdash (M\;\tau) : \sigma\subst{v}{\tau}$}
  \end{prooftree}
  \end{multicols}
\end{definition}
\begin{example} \label{ex:f-welltyped}
  The following terms are well-typed:
  \begin{enumerate}
    \item ${}\vdash\Lambda v.\,\lambda (x : v).\, x : \forall v.\;v\to v$
    \item ${}\vdash\Lambda v.\, \lambda (x : v)(y : v).\, x : \forall v.\;v \to v \to v$
    \item $M : \sigma, N : \sigma
      \vdash (\Lambda v.\, \lambda (x : v)(y : v).\, x)\;\sigma\;M\;N
      : \sigma \to \sigma \to \sigma$
    \item ${}\vdash\Lambda v.\, \lambda (f : v \to v)(x : v).\, f\;f\;x : 
      \forall v.\;(v\to v) \to v\to v$
    \end{enumerate}
\end{example}
We derive the second one and leave other to the reader.
\begin{prooftree}
  \AXC{}
  \RightLabel{(var)}
  \UIC{$x : v, y : v \vdash x : v$}
  \UIC{$x : v \vdash \lambda (y : v).\; x : v \to v$}
  \UIC{$\vdash \lambda (x : v)(y : v).\; x : v \to v \to v$}
  \UIC{$\vdash \Lambda v.\,\lambda (x : v)(y : v).\; x :\forall v.\,v \to v \to v$}
\end{prooftree}

In line with the new syntax, we also need to extend \emph{substitution over
  terms} and \emph{$\beta$-reduction} to take account of type variable in $(M
\tau)$. However, we can also erase the type information of well-typed terms, and
reduce it, as if untyped by Preservation Theorem. To be precise, we state the
erasing map and the result without any proof.
\begin{definition}
  The \emph{erasing map} is a function from typed terms in polymorphic lambda
  calculus to untyped terms in lambda calculus defined inductively 
  \begin{align*}
    |x| & = x \\
    |\lambda (x : \tau).\,M| & = \lambda x.\, |M| \\
    |(M\;N)| & = (|M|\;|N|) \\
    |\Lambda v.\, M| & = |M| \\
    |M\;\tau| & = |M|
  \end{align*}
\end{definition}
\begin{theorem}[Preservation Theorem]
  Within polymorphic lambda calculus, if ${}\vdash M : \sigma$ and $|M|
  \onereduce N$, then there exists some typed-term~$N$ with
  ${}\vdash N : \sigma$.
\end{theorem}
\subsection*{Exercise}
\begin{enumerate}
  \item Complete Example~\ref{ex:f-terms} and Example~\ref{ex:f-welltyped}.
\end{enumerate}
\section{Data types in System F}
Thanks to type polymorphism, the system can now express much more types,
including the \emph{product type}, the \emph{sum type}, the type of
\emph{natural number}, the type of \emph{lists}, and more.
\subsection{Sum type}
First of all, the sum type of $\tau$ and $\sigma$ represent the
``disjoint union'' of two types. 
\[
  \sigma + \tau \defeq \forall v. (\sigma \to v) \to (\tau \to v) \to v
\]
The intuition is that every term of $\sigma + \tau$ has two ``constructors''
$(\sigma \to v)$
Also the first injection is defined by
\begin{align*}
  \vdash {} & \mathtt{inj}_1 \colon \sigma \to \sigma + \tau \\
  & \mathtt{inj}_1 \defeq \lambda (x : \sigma).\;\Lambda v.\,\lambda (f :
  \sigma\to v)(g : \tau\to v).\, f\;x 
\end{align*}
and similarly the second injection
\begin{align*}
  \vdash {} & \mathtt{inj}_2 \colon \tau \to \sigma + \tau \\
  & \mathtt{inj}_2 \defeq ?
\end{align*}
(Find the exact definition of $\mathtt{inj}_2$.)

With the sum type, we can implement the usual construct \texttt{case}:
\[
  \vdash \mathtt{case} : \forall\,\rho.\;(\sigma \to \rho) \to (\tau \to \rho)
  \to (\sigma + \tau) \to \rho
\]
which returns a term of type $\rho$ given functions $\sigma \to \rho$, $\tau \to
\rho$, and a term which is either of type $\sigma$ or $\tau$. Try to find the
exact definition of $\mathtt{case}$.
\subsection{Product type}
The product type can be defined as
\[
  \sigma \times \tau \defeq \forall v. (\sigma \to \tau \to v) \to v
\]
with the pairing function
\begin{align*}
  {} \vdash & \lambda (x : \sigma)(y : \tau).\; \left< x, y\right> :
  \sigma \to \tau \to \sigma
  \times \tau \\
  & \left< x, y\right> \defeq \Lambda v.\,\lambda (f : \sigma \to \tau \to v).\,
  f\;x\;y
\end{align*}
Try to define projections 
\[
  \mathtt{proj}_1 : \sigma \times \tau \to \sigma
  \quad\text{and}\quad
  \mathtt{proj}_2 : \sigma\times \tau \to \tau
\]
\subsection{Natural numbers}
Back to Church numerals, we can now define them with a single type:
\[
  \nat \defeq \forall v.\, (v\to v)\to v\to v
\]
  \begin{description}
    \item[Polymorphic Church numerals]
      \begin{align*}
        \vdash{} & \bc_n : \nat \\
        & \bc_n \defeq \Lambda v.\,\lambda (f:v \to v)\,(x:v).\,
        f^n x
      \end{align*}
    \item[Successor]
      \begin{align*}
        \vdash{} & \suc : \nat \to \nat \\
        & \suc \defeq \,\lambda (n : \nat).\,\Lambda v.\,\lambda
        (f : v \to v)\,(x:v)\,.\;f\;(n\;v\;f\;x) 
      \end{align*}
    \item[Addition]
      \begin{align*}
        \vdash{} & \add : \nat \to \nat \to \nat \\
        & \add \defeq \lambda (n : \nat)\,(m:\nat)\,\Lambda v.\,
        \lambda (f:v\to v)\,(x: v).\; (m\;v\;f)\;(n\;v\;f\;x) 
      \end{align*}
    \item[Multiplication] 
      \begin{align*}
      \vdash{} & \mul : \nat\to \nat \\
        & \mul \defeq\,?
      \end{align*}
    \item[Conditional]
      \begin{align*}
        \vdash {} & \ifz : \forall v.\,\nat \to v \to v \to v \\
        & \ifz \defeq\,?
      \end{align*}
  \end{description}
However, polymorphic lambda calculus allows us to define a certain form of
recursion on Church numerals, called \emph{primitive recursion} or the
\texttt{fold} function which you have seen in Haskell.
\begin{align*}
  \vdash{} & \mathtt{fold} : \forall v.\, (v \to v) \to v \to \nat \to v  \\
  & \mathtt{fold} \defeq \Lambda v.\, \lambda (f : v \to v)(e : v)(n : \nat). 
  n\;v\;f\;e
\end{align*}
The addition, multiplication, and predecessor operations can be redefined as
follows:
\begin{example}
  Find the types of following terms and justify your answer.
  \begin{enumerate}
    \item $\add' \defeq \mathtt{fold}\;\nat\;\suc\;\bc_0$
    \item $\pred \defeq \mathtt{fold}\;\nat\;(\lambda (f : \nat \to \nat)(x : \nat).\,
      x)\;\bc_0$
  \end{enumerate}
  Moreover, show that each of them reduces to the expected Church numerals
  \begin{enumerate}
    \item $\pred\;\bc_0 \reduce \bc_0$ and $\pred\;\bc_{n+1}
      \reduce \bc_n$.
    \item $\add'\;\bc_n\;\bc_m \reduce \bc_{n+m}$.
  \end{enumerate}
\end{example}
\subsection{List}
Finally, the type of list over a type~$\sigma$ can also be defined in
polymorphic lambda calculus. It is similar to the type of natural numbers:
\[
  \List\,\sigma\defeq \forall v.\, v \to (\sigma \to v \to v) \to v 
\]
with ``list constructors'' 
\begin{enumerate}
  \item $\mathtt{nil}_\sigma \defeq \Lambda v.\lambda (h : v)(f :
    \sigma\to v \to v).\, h$
  \item $\mathtt{cons}_\sigma \defeq \lambda (x : \sigma)(xs : \List
    \sigma).\,\Lambda v.\lambda(h : v)(f : \sigma\to v \to v).f\,x\,(xs\; v\;
    h\; f)$ which has the type $\sigma \to \List \sigma \to  \List \sigma$.
  \end{enumerate}
\subsection*{Exercise}
\begin{enumerate}
  \item Define $\mathtt{fold}$ over the list type over~$\sigma$.
  \item Define $\mathtt{length}_{\sigma} : \List \sigma \to \nat$ calculating
    the length of a given list so that
    \[
      \mathtt{length}\;\mathtt{nil}_\sigma \reduce \bc_0
      \quad\text{and}\quad
      \mathtt{length}\;(\mathtt{cons}_\sigma\;x\;xs)
      \reduce \suc\;(\mathtt{length}\;xs) 
    \]
  \end{enumerate}

\section{Parametricity}

\[
  \bot \defeq \forall v.v
\]
\subsection*{Exercise}


\end{document}
