%! TEX root = lecture2_note.tex
\title{Lambda Calculus and Types, 2 \\<all>
  Simply Typed Lambda Calculus}
\begin{document}
\begin{frame}
\maketitle
\end{frame}

\section{Simply typed lambda calculus}
As we have seen in the first lecture, $\lambda$-terms can ``call'' themselves,
projections $\mathbf{K}_1$ and $\mathbf{K}_2$ can also be viewed as Boolean
values, and so on. Despite its powerfulness, the expressiveness can be a
disaster if treated as a programming language, because it is difficult to see the
intention of such terms. 

This motivates us to introduce \emph{types} over $\lambda$-terms. There are two
approaches given by Curry and Church corresponding to
two paradigms in programming language called \emph{implicit} and \emph{explicit
  typing} respectively.  In the typed lambda calculus \emph{\`a la} Curry, a
$\lambda$-term is assigned to all possible types; while in the calculus
\emph{\`a la} Church, a $\lambda$-term is annotated with types. 

\subsection{Implicit typing: system with type assignment}
For an implicit typing system, types are defined in addition to $\lambda$-terms.
We begin a minimalistic typing system consisting of function types and primitive
types such as types of Boolean values, natural numbers, etc. 
\begin{definition}
  Given a collection $\mathbb{G}$ of ground types (a.k.a.\ primitive types), the
  collection $\mathbb{T} = \mathbb{T}_\mathbb{G}$ of \emph{types} is inductively
  defined as \begin{multicols}{2}
    \begin{prooftree}
      \AXC{$B \in \mathbb{G}$}
      \UIC{$B \in \mathbb{T}$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$\sigma \in \mathbb{T}$}
      \AXC{$\tau   \in \mathbb{T}$}
      \RightLabel{(function)}
      \BIC{$\sigma \to \tau \in \mathbb{T}$}
    \end{prooftree}
  \end{multicols}
\end{definition}
\begin{definition}
  Given a set of variables and a set of ground types, we define the following
  notions.
  \begin{enumerate}
    \item A \emph{statement} consists of a $\lambda$-term~$M$
      and a type~$\sigma \in \mathbb{T}$ denoted by 
      \[
        M : \sigma
      \]
      and we say that $M$ has the type $\sigma$.
    \item A \emph{context}~$\Gamma$ is a (possibly infinite) set of statements 
      \[
        \Gamma = \{x_1 : \sigma_1, x_2 : \sigma_2, \ldots, x_n : \sigma_n\}
      \]
      where $x_i$ are all distinct variables. 
  \end{enumerate}
\end{definition}
A judgement in the system of assignment is constructed inductively as follows:
\begin{definition}[Typing rules]
  A \emph{judgement} consists of a context~$\Gamma$ and a statement~$M:\sigma$ denoted by
      \[
        \Gamma \vdash M : \sigma
      \]
  indicating that $M : \sigma$ is derivable from $\Gamma$. Judgements in the
  system of type assignment are constructed inductively as follows:
  \begin{multicols}{2} 
  \begin{prooftree}
    \AXC{$(x : \sigma) \in \Gamma$}
    \RightLabel{(var)}
    \UIC{$\Gamma \vdash x : \sigma$}
  \end{prooftree}
  \begin{prooftree}
    \AXC{$\Gamma \vdash M : (\sigma \to \tau)$}
    \AXC{$\Gamma \vdash N : \sigma$}
    \RightLabel{(app)}
    \BIC{$\Gamma \vdash (M\;N) : \tau$}
  \end{prooftree}
  \begin{prooftree}
    \AXC{$\Gamma, x : \sigma \vdash M : \tau$}
    \RightLabel{(abs)}
    \UIC{$\Gamma \vdash \lambda x.\; M : (\sigma \to \tau)$}
  \end{prooftree}
  \end{multicols}
\end{definition}

\begin{example}
  The following judgements are derivable:
  \begin{enumerate}
    \item $\vdash \lambda x.\, x : \sigma \to \sigma$, for all $\sigma \in
      \mathbb{T}$;
    \item $ \vdash \lambda x.\, (\lambda y.\, x) : \sigma \to (\tau \to \sigma)$
      for all $\sigma, \tau\in\mathbb{T}$;
    \item $\vdash \lambda f.\,\lambda g.\, \lambda x.\, (f\,x)\, (g\,y) 
      : (\sigma \to \tau \to \rho) \to (\sigma\to\tau) \to \sigma\to\rho$
      for all $\sigma, \tau, \rho \in \mathbb{T}$.
  \end{enumerate}
  To see why the first judgement is derivable, we apply typing rules
  step by step:
  \begin{prooftree}
    \AXC{$x : \sigma \in \Gamma, x : \sigma$}
    \RightLabel{(var)}
    \UIC{$\Gamma, x : \sigma \vdash x : \sigma$}
    \RightLabel{(abs)}
    \UIC{$\Gamma \vdash \lambda x.\; x : (\sigma \to \sigma)$}
  \end{prooftree}
  And, also the second one:
  \begin{prooftree}
    \AXC{$x : \sigma \in x : \sigma, y:\tau$}
    \RightLabel{(var)}
    \UIC{$x : \sigma, y: \tau \vdash x : \sigma$}
    \RightLabel{(abs)}
    \UIC{$x : \sigma \vdash \lambda y.\, x : \tau \to \sigma$}
    \RightLabel{(app)}
    \UIC{$\vdash \lambda x.\, (\lambda y.\, x) : \sigma \to (\tau \to \sigma)$}
  \end{prooftree}
  The third one is left as an exercise to the reader.
\end{example}
\begin{example}
  Not every $\lambda$-term has a type. For example,
  \[
    \lambda x.\, x\,x
  \]
  does not have a type, since $\sigma \to \sigma$ is not equal to $\sigma$.
\end{example}


Let's come back to some practical issues of our system.  In addition to the
above three rules, we often add rules for primitive types, and pick variables in
$\Lambda$ as constants of that type. For example, we may start with a context
\[
  \Gamma_\nat = \{\zero : \nat, \suc : \nat \to \nat\}
\]
and define $\underline{n} \defeq \suc^n\;\zero$. In this way, we can derive
every $\underline{n}$ has the type of $\nat$:
\[
  \Gamma_\nat \vdash \underline{n} : \nat
\]

In practice, the type inference is left to the evaluator of a programming
language, so it is natural to ask if this system of assignment has the following
properties:
\begin{description}
  \item[Typability:] Is there a type $\sigma$ with $\vdash M : \sigma$? 
  \item[Type checking:] Does $\vdash M : \sigma$ hold for a given type $\sigma$?
  \end{description}
\begin{theorem}
  Typability and type checking are both \emph{decidable}.
\end{theorem}
%See \cite[Section 3.2]{Sorensen2006} for further detail.

\subsection{Explicit typing: system of typed terms}
Instead of having an external typing system, it is also possible to internalise
the typing information as part of $\lambda$-terms:
$\lambda$-terms are now
annotated:
\begin{definition}
  The set $\Lambda_\mathbb{T}$ of typed $\lambda$-terms is inductively defined
  \begin{multicols}{2}
    \begin{prooftree}
      \AXC{$x \in V$}
      \UIC{$x \in \Lambda_\T$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$M \in \Lambda_\T$}
      \AXC{$N \in \Lambda_\T$}
      \BIC{$(M\, N) \in \Lambda_\T$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$M \in \Lambda_\T$}
      \AXC{$x \in V$}
      \AXC{$\tau \in \mathbb{T}$}
      \TIC{$\lambda (x:\tau).\; M \in \Lambda_\T$}
    \end{prooftree}
  \end{multicols}
\end{definition}
Likewise, the \emph{substitution} and the \emph{one-step $\beta$-reduction} are
defined on typed $\lambda$-terms in the same way.
\begin{definition}[Typing rules]
  A judgement $\Gamma \vdash M : \sigma$ on typed terms is constructed
  inductively by the following rules.
  \begin{multicols}{2} 
  \begin{prooftree}
    \AXC{$(x : \sigma) \in \Gamma$}
    \RightLabel{(var)}
    \UIC{$\Gamma \vdash x : \sigma$}
  \end{prooftree}
  \begin{prooftree}
    \AXC{$\Gamma \vdash M : (\sigma \to \tau)$}
    \AXC{$\Gamma \vdash N : \sigma$}
    \RightLabel{(app)}
    \BIC{$\Gamma \vdash (M\;N) : \tau$}
  \end{prooftree}
  \begin{prooftree}
    \AXC{$\Gamma, x : \sigma \vdash M : \tau$}
    \RightLabel{(abs)}
    \UIC{$\Gamma \vdash \lambda (x:\sigma).\; M : (\sigma \to \tau)$}
  \end{prooftree}
  \end{multicols}
\end{definition}

The typing information can be erased from typed terms, but typability still
remains.
\begin{definition}
  An \emph{erasing map} $|-|\colon \Lambda_\T \to \Lambda$ is defined inductively:
  \todo[inline]{finish it}
\end{definition}
\begin{proposition}
  The following statements are true:
  \todo[inline]{translation}
\end{proposition}
\subsection*{Exercise}
\begin{enumerate}
  \item Show that $\Omega$ does not have a type.
  \item Show that $\vdash \mathbf{K}_1\;\mathbf{I}\;\Omega : \sigma \to \sigma$
    does not have a type.
  \item Show that $\lambda (x : \sigma).\, x\; x$ is a typed $\lambda$-term but
    there exists no type $\tau$ with 
    \[
      \vdash \lambda (x : \sigma).\, x\; x : \tau.
    \]
  \end{enumerate}
\section{Type safety}
\subsection{Preservation}
One of the main features of typed programs is that ``well-typed programs do not
go wrong'':
\begin{theorem}[Preservation]
  Suppose that $M \reduce N$. Then, 
  \[
    \Gamma \vdash M : \sigma \implies \Gamma \vdash N : \sigma
  \]
\end{theorem}
\begin{proof}
\end{proof}
However, the converse may not hold. Observe the following examples
\begin{example}
  Recall that 
  \begin{enumerate}
    \item $\mathbf{I} = \lambda x.\, x$
    \item $\mathbf{K}_1 = \lambda x.\, \lambda y.\, x$
    \item $\Omega = (\lambda x.\, x\,x)\,(\lambda x.\, x\,x)$
  \end{enumerate}
  and $\mathbf{K}_1\,\mathbf{I}\,\Omega \reduce \mathbf{I}$. However, 
  \[
    \vdash \mathbf{I} : \sigma \to \sigma
    \not\implies
    \vdash \mathbf{K}_1\;\mathbf{I}\;\Omega : \sigma \to \sigma.
  \]
\end{example}
To see why the latter judgement fails, we need the following lemma:
\begin{lemma}[Typability of subterms]
  Let $M$ be a  $\lambda$-term and $\sigma$ a type. Then,  
  \[
    \Gamma \vdash M : \sigma 
    \implies \Gamma' \vdash M' : \sigma'
  \]
  for every subterm $M'$ of~$M$.
\end{lemma}
\subsection{Progress}
\subsection{Strong normalisation}
\subsection*{Exercise}
\section{Programming in simply typed lambda calculus}
\todo[inline]{Primitive recursion}
\subsection*{Exercise}
\todo[inline]{Introduce PCF}

\bibliographystyle{plain}
\bibliography{../../library} 
\end{document}
