\title{Lambda Calculus and Types}
\author[L.-T. Chen]{Chen, Liang-Ting\\
  \href{mailto:ltchen@hawaii.edu}{\texttt{ltchen@hawaii.edu}}}
\institute{Department of Information and Computer Sciences, University of Hawaii
at Manoa}
\begin{document}
\begin{frame}
\maketitle
\end{frame}

The aim of this course is to teach the practical part of untyped and typed
lambda calculus which is the formalisation of functional programming,
and unfortunately we have to omit the computability aspect due to time
constraints. Another aspect we will not discuss is the denotational semantic of
lambda calculus. It is one of the well-studied subject in theoretical computer
science but it requires a mathematical background.

\todo{historical remark}

For further details about lambda calculus, the reader is referred
to~\cite{Barendregt1984,Barendregt1992}. 

\section{Untyped lambda calculus}
We begin with an informal introduction to lambda calculus. Lambda calculus can
be viewed as a simplest programming language whose syntax only consists of
\begin{enumerate}[(a)]
  \item infinitely many variables $x, y, z, \ldots$, 
  \item function application $F(a)$, or just $F a$, and
  \item function abstraction $F(x) \defeq M$, or just $\lambda x.\, M$
    as an anonymous function, whose intuitive meaning is to define a function
    with a parameter~$x$.
\end{enumerate}
The only possible computation is the substitution for the parameter in the
function body by its argument, written as 
\[
  (\lambda x.\, M)\, N \leadsto M\subst{x}{N}
\]
and the computation is finished while there is no possible reduction, e.g.
\[
  (\lambda x.\, \lambda y.\, (x y) z) (\lambda x.\, x)
  \leadsto (\lambda y.\, (x y) z)\subst{x}{(\lambda x.\, x)}
  \leadsto \lambda y.\, (\lambda x.\, x) y z
  \leadsto \lambda y.\, (x\subst{x}{y}) z
  \leadsto \lambda y.\, y z
\]

\subsection{Syntax, alpha-conversion, beta-reduction}
\begin{definition}[Syntax]
  Let $V \defeq \{ x, y, z, \ldots \}$ be a countably infinite set of
  \emph{variables}.  The set $\Lambda = \Lambda_V$ of \emph{$\lambda$-terms} is
  defined inductively
  \begin{columns}
    \column{.3\textwidth}
    \begin{prooftree}
      \AXC{$x \in V$}
      \RightLabel{(variable)}
      \UIC{$x \in \Lambda$}
    \end{prooftree}
    \column{.3\textwidth}
    \begin{prooftree}
      \AXC{$M, N \in \Lambda$}
      \RightLabel{(application)}
      \UIC{$(M\, N) \in \Lambda$}
    \end{prooftree}
    \column{.3\textwidth}
    \begin{prooftree}
      \AXC{$M \in \Lambda, x \in V$}
      \RightLabel{(abstraction)}
      \UIC{$\lambda x.\, M \in \Lambda$}
    \end{prooftree}
  \end{columns}
  Equivalently, $\Lambda$ is the language generated by the following
  context-free grammar:
  \[
  \Lambda \longrightarrow V \mid (\Lambda\, \Lambda) \mid \lambda V.\, \Lambda
  \]
\end{definition}
Throughout this lecture, we assume that $V$ is the variable set for
$\lambda$-terms. 
\begin{definition}[Free variables, closed terms, and substitution]
  \begin{enumerate}[(a)]
    \item The free variable set $\FV\colon \Lambda \to V$ is a function from the
      set~$\Lambda$ of $\lambda$-terms to the variable set~$V$ defined
      inductively as follows:
      \begin{align*}
        \FV(x) & = \{ x \} \\
        \FV(M\, N) & = \FV(M) \cup \FV(N) \\
        \FV(\lambda x.\, M) & = \FV(M) - \{ x \}.
      \end{align*}
      That is, a variable $v$ of a $\lambda$-term~$M$ is \emph{free} if $v \in
      \FV(M)$, otherwise $v$ in a $\lambda$-term is
      \emph{bound}. The set of bound variable is denoted by~$\BV(M)$.
    \item A $\lambda$-term~$M$ is \emph{closed} or a
      \emph{combinator} if $\FV(M) = \emptyset$. That
      is, $M$ contains no free variable. Closed terms are also called
      \emph{combinators}.
    \item The \emph{(capture-avoidance) substitution} of $P$ for the free occurrences of $x$ is a
      partial function mapping a $\lambda$-term $M$ to another $\lambda$-term,
      denoted by $M\subst{x}{P}$, defined inductively as follows:
      \begin{align*}
        x\subst{x}{P} & = P \\
        y\subst{x}{P} & = y && \text{if $x \neq y$} \\
        (M\, N)\subst{x}{P} & = (M\subst{x}{P}\, N\subst{x}{P}) \\
        (\lambda x.\, M)\subst{x}{P} & = (\lambda x.\, M) \\
        (\lambda y.\, M)\subst{x}{P} & = (\lambda y.\, M\subst x P)
        && \text{if $x \neq y$, and $y \not\in \FV(P)$.}\\
      \end{align*}
  \end{enumerate}
\end{definition}

\begin{convention}
  We do \emph{NOT} distinguish two $\lambda$-terms if they only differ in the
  name of bound variables. For example, $(\lambda x.\, x)$ may be renamed to 
  $(\lambda y.\, y)$, and we consider them the same.
\end{convention}
\begin{definition}[$\alpha$-equivalence: renaming of bound variables]
  Whenever a variable $y$ does not occur freely in~$M$, we can rename the bound
  variable $x$ in~$\lambda x.\, M$, i.e.\ 
  \[
    (\lambda x.\, M) \equiv_\alpha (\lambda y.\, M\subst{x}{y})
  \]
  if $y \not\in \FV(M)$. We also need to carry this identification through every
  subterm, so we add the following congruence rule
  \begin{columns}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{$M \equiv_\alpha M'$}
      \UIC{$M\,N \equiv_\alpha M'\,N$}
    \end{prooftree}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{$N \equiv_\alpha N'$}
      \UIC{$M\,N \equiv_\alpha M\,N'$}
    \end{prooftree}
  \end{columns}
  and also the reflexivity, symmetry and, transitivity.
\end{definition}
\begin{definition}[$\beta$-conversion: reduction]
  An application of this form $(\lambda x.\, M)\, N$ reduces to a
  $\lambda$-term~$M\subst{x}{N}$. Symbolically, we write 
  \[
    (\lambda x.\, M)\, N \leadsto_\beta M\subst{x}{N}
  \]
  where the conversion $\leadsto_\beta$ is called \emph{$\beta$-conversion} or
  sometime \emph{$\beta$-reduction}. However, $\beta$-reduction can happen in
  a subterm inside a $\lambda$-term, so we add the following congruence rules:
  \begin{columns}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{$M \leadsto_\beta M'$}
      \UIC{$M N \leadsto_\beta M' N$}
    \end{prooftree}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{$N \leadsto_\beta N'$}
      \UIC{$M N \leadsto_\beta M N'$}
    \end{prooftree}
  \end{columns}
\end{definition}
\subsection{Reduction strategies}
\subsubsection*{Call-by-name and call-by-value}
\subsubsection*{Church-Rosser Theorem}
\begin{definition}
\end{definition}
\subsection{Programming in lambda calculus}
\subsubsection*{Church numerals, Booleans, and pairing}

There is no \emph{built-in} natural number in lambda calculus. However, 
not only every natural number can be defined as a $\lambda$-term, but also 
operations, e.g.\ addition, multiplication, and even exponential, on natural
number can be defined. In fact, every computable function (on natural numbers)
is definable in lambda calculus. 
\begin{definition}[Church numerals]
  
\end{definition}

\begin{definition}[Addition]
\end{definition}

\begin{definition}[Boolean values]
  \[
    \mathtt{T} \defeq \lambda x.\,\lambda y.\, x
    \quad\text{and}\quad
    \mathtt{F} \defeq \lambda x.\,\lambda y.\, y
  \]
\end{definition}
\subsubsection{Combinators}

\subsubsection*{Fixed-point combinator}

\subsection*{Exercise}
\begin{enumerate}
  \item Give an inductive definition of bound variable. That is, define a
    function $\BV\colon \Lambda \to V$ inductively
    such that $\BV(M)$ is exactly the set of bound variable in a
    $\lambda$-term~$M$.

\end{enumerate}

\bibliographystyle{plain}
\bibliography{library} 
\end{document}
