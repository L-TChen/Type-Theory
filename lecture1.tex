%! TEX root = lecture1_note.tex
\title{Lambda Calculus and Types:\\<all>
  Untyped Lambda Calculus}
\begin{document}
\begin{frame}
\maketitle
\end{frame}

We begin with an informal introduction to lambda calculus. Lambda calculus can
be viewed as a simplest programming language whose syntax only consists of
\begin{enumerate}[(a)]
  \item infinitely many variables $x, y, z, \ldots$, 
  \item function application $F(a)$, or just $F a$, and
  \item function abstraction $F(x) \defeq M$, or just $\lambda x.\, M$
    as an anonymous function, whose intuitive meaning is to define a function
    with a parameter~$x$.
\end{enumerate}
The only possible computation is the substitution for the parameter in the
function body by its argument, written as 
\[
  (\lambda x.\, M)\, N \leadsto M\subst{x}{N}
\]
and the computation is finished while there is no possible reduction, e.g.
\[
  (\lambda x.\, \lambda y.\, (x y) z) (\lambda x.\, x)
  \leadsto (\lambda y.\, (x y) z)\subst{x}{(\lambda x.\, x)}
  \leadsto \lambda y.\, (\lambda x.\, x) y z
  \leadsto \lambda y.\, (x\subst{x}{y}) z
  \leadsto \lambda y.\, y z
\]

\section{Introduction}

\begin{definition}[Syntax]
  Let $V \defeq \{ x, y, z, \ldots \}$ be a countably infinite set of
  \emph{variables}.  Then, \emph{$\lambda$-terms} are defined inductively:
  \begin{multicols}{3}
    \begin{prooftree}
      \AXC{$x \in V$}
      \RightLabel{(var)}
      \UIC{$x \in \Lambda$}
    \end{prooftree}
    \columnbreak
    \begin{prooftree}
      \AXC{$M, N \in \Lambda$}
      \RightLabel{(app)}
      \UIC{$(M\, N) \in \Lambda$}
    \end{prooftree}
    \columnbreak
    \begin{prooftree}
      \AXC{$M \in \Lambda, x \in V$}
      \RightLabel{(abs)}
      \UIC{$\lambda x.\, M \in \Lambda$}
    \end{prooftree}
  \end{multicols}
  \noindent corresponding to the introduction of \emph{variables},
  \emph{application}, and \emph{abstraction}.
\end{definition}
Equivalently, $\Lambda$ is the language generated by the following
context-free grammar:
\[
\Lambda \longrightarrow V \mid (\Lambda\, \Lambda) \mid \lambda V.\, \Lambda.
\]
Throughout this lecture, we assume that $V$ is the variable set for
$\lambda$-terms. 
\begin{definition}[Free variables, closed terms, and substitution]
  \begin{enumerate}[(a)]
    \item The free variable set $\FV\colon \Lambda \to V$ is a function from the
      set~$\Lambda$ of $\lambda$-terms to the variable set~$V$ defined
      inductively as follows:
      \begin{align*}
        \FV(x) & = \{ x \} \\
        \FV(M\, N) & = \FV(M) \cup \FV(N) \\
        \FV(\lambda x.\, M) & = \FV(M) - \{ x \}.
      \end{align*}
      That is, a variable $v$ of a $\lambda$-term~$M$ is \emph{free} if $v \in
      \FV(M)$, otherwise $v$ in a $\lambda$-term is
      \emph{bound}. The set of bound variable is denoted by~$\BV(M)$.
    \item A $\lambda$-term~$M$ is called \emph{closed} or a \emph{combinator} if
      $\FV(M) = \emptyset$. That
      is, $M$ contains no free variable.
  \end{enumerate}
\end{definition}

\subsection{Substitution}
One of the most subtle definition in lambda calculus is the \emph{substitution},
as we shall follow the principle that free variables remain free after
substitution. Consider the following case:
\[
  (\lambda x.\, \lambda y.\, f\,x\, y)
\]
It is intended to be a function wrapping another term with two inputs $x$ and
$y$. Then, the following term
\[
  ((\lambda x.\, \lambda y.\, f\,x\, y)\,y)\,z
\]
is supposed to replace variables $x$ and $y$ by $y$ and $z$ respectively, right? 
Try it step by step:
\begin{align}
 ((\lambda x.\, \lambda y.\, f\,x\, y)\, y)\, z  \to{}
        & ((\lambda y.\, f\,x\,y)\subst{x}{y})\, \, z  \label{eq:subst-ex} \\
  ={}   & (\lambda y.\, f\,y\,y)\,z \\
  \to{} & (f\,y\,y)\subst{y}{z} \\
  ={}   & f\,z\,z
\end{align}
The variable $y$ is gone! 
We can avoid this unwanted situation by renaming the bound variables in a
$\lambda$-term first:
\[
  ((\lambda x'.\,(\lambda y'.\, f\,x'\,y'))\, y)\, z
  \to (\lambda y'.\, f\,y\,y')\,z
  \to f\,y\,z
\]
The following sections are devoted to a correct definition of reduction.
First of all, we do not perform substitution if any free variable
becomes bound after substitution:
\begin{definition}
    The \emph{(capture-avoidance) substitution} of $P$ for the free occurrences
    of $x$ is a partial function mapping a $\lambda$-term $M$ to another
    $\lambda$-term, denoted by $M\subst{x}{P}$, defined inductively as follows:
    \begin{align*}
      x\subst{x}{P} & = P \\
      y\subst{x}{P} & = y && \text{if $x \neq y$} \\
      (M\, N)\subst{x}{P} & = (M\subst{x}{P}\, N\subst{x}{P}) \\
      (\lambda x.\, M)\subst{x}{P} & = (\lambda x.\, M) \\
      (\lambda y.\, M)\subst{x}{P} & = (\lambda y.\, M\subst x P)
      && \text{if $x \neq y$, and $y \not\in \FV(P)$.}\\
    \end{align*}
\end{definition}
Given this new definition, the substitution in \eqref{eq:subst-ex} is
not allowed (or, undefined):
\[
  (\lambda y.\, f\,x\,y)\subst{x}{y}
\]
\subsection{$\alpha$-conversion}
Secondly, we identify any two $\lambda$-terms if they only differ in the name of
bound variables.

For example, $(\lambda x.\, x)$ may be renamed to $(\lambda y.\, y)$, and we
consider them the same. The name of variable do not affect program behaviours
but only readability. We say that two terms $M$ and $N$ are \emph{equivalent up
  to renaming (of bound variables)}, if $N$ can be derived from~$M$ by renaming
bound variables.

This identification can be defined formally through the following two steps.
\begin{definition}[Congruence]
  A congruence is an equivalence relation in respect of the structure of
  $\lambda$-terms:
  \begin{enumerate}
    \item An \emph{congruence} on $\lambda$-terms is an equivalence
      relation~$\sim$ on $\lambda$-terms subject to following additional
      structural rules
      \begin{multicols}{2}
        \begin{prooftree}
          \AXC{$M_1\sim M_2$}
          \AXC{$N_1\sim N_2$}
          \BIC{$M_1\,N_1\sim M_2\,N_2$}
        \end{prooftree}
        \begin{prooftree}
          \AXC{$M_1\sim M_2$}
          \UIC{$\lambda x.\, M_1\sim \lambda x.\, M_2$}
        \end{prooftree}
      \end{multicols}
    \item The congruence closure of a relation~$R$ on $\lambda$-terms is the
      least congruence~$\overline{R}$ containing~$R$. 
  \end{enumerate}
\end{definition}

\begin{definition}[$\alpha$-conversion: renaming of bound variables]
  Whenever a variable $y$ does not occur freely in~$M$, we can rename the bound
  variable $x$ in~$\lambda x.\, M$ to~$y$, i.e.\ 
  \[
    (\lambda x.\, M) \to_\alpha (\lambda y.\, M\subst{x}{y})
  \]
  if $y \not\in \FV(M)$. The relation
  $\to_\alpha$ is called $\alpha$-conversion. Let $\equiv_\alpha$ be the
  congruence closure of~$\to_\alpha$. We say that $M$ and $N$ are
  \emph{$\alpha$-equivalent} if $M \equiv_\alpha N$.
\end{definition}

\subsection{$\beta$-conversion}
Now, we can give a definition of reduction on a term of this form~$(\lambda
x.\, M)\, N$ (only):
\begin{definition}[$\beta$-conversion]
  A term $(\lambda x.\, M)\, N$ can reduce to $M'\subst{x'}{N}$ whenever the
  substitution is defined and $(\lambda x'.\, M')$ is $\alpha$-equivalent to
  $(\lambda x.\, M)$. 
  That is,
  \[
    (\lambda x.\, M)\, N \xrightarrow{\beta} M'\subst{x'}{N}
  \]
  if $(\lambda x.\, M)$ is $\alpha$-equivalent to $(\lambda x'.\, M')$ and
  $M'\subst{x'}{N}$ is defined.  A term of this form $(\lambda x.\, M)\, N$ is
  called a \emph{$\beta$-redex}.
\end{definition}
Yet, the definition is not complete. A reduction may be performed inside a
$\lambda$-term like $\lambda y.\, (\lambda x.\, x)\, M$. Similar to the
definition of $\alpha$-equivalence, we define:
\begin{definition}[One-step $\beta$-reduction]
  The \emph{one-step $\beta$-reduction} is a relation on $\lambda$-terms
  defined inductively as follows:
  \begin{multicols}{2}
    \begin{prooftree}
      \AXC{$M_1 \xrightarrow{\beta} M_2$}
      \UIC{$M_1 \onereduce M_2$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$M_1 \onereduce M_2$}
      \UIC{$\lambda x.\, M_1 \onereduce \lambda x.\, M_2$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$M_1 \onereduce M_2$}
      \AXC{$N_1\onereduce  N_2$}
      \BIC{$M_1\,N_1 \onereduce M_2\,N_2$}
    \end{prooftree}
  \end{multicols}
\end{definition}
%
%\begin{definition}
%  The \emph{$\lambda$-theory} of $\lambda$-terms is the congruence closure,
%  denoted by~$\equiv$, of $\alpha$-conversion~$\to_\alpha$ and
%  $\beta$-conversion~$\to_\beta$.
%\end{definition}
%The $\lambda$-theory identifies $\lambda$-terms ought to have the same
%meaning. 
However, given this definition of one-step $\beta$-reduction, we only know what a
\emph{correct} step of reduction is, but we still do not know \emph{how} 
a reduction should be performed in a systematic way---a term may have multiple
reductions at the same time. Given $\lambda$-terms $M$ and~$N$, consider the following
\[
  (\lambda x.\, (\lambda y.\, M)\,x)\,
  (\lambda x.\, (\lambda y.\, N)\,x)
\]
and write down all possible chains of reductions.
\subsection*{Exercise}
\begin{enumerate}
  \item Give an inductive definition of bound variable. That is, define a
    function $\BV\colon \Lambda \to V$ inductively
    such that $\BV(M)$ is exactly the set of bound variable in a
    $\lambda$-term~$M$.
\end{enumerate}

\section{Reduction}
\subsection{Reduction strategy}
Informally, a reduction strategy is a procedure of selecting $\beta$-redexes
to be reduced if there are multiple choices. 
\begin{definition}
  A \emph{reduction strategy} is a relation $\leadsto$ on $\lambda$-terms
  such that
  \begin{enumerate}[(a)]
    \item every reduction is a valid step of $\beta$-reduction:
      $M \leadsto N$ implies $M \onereduce N$;
    \item every step is unique up to renaming of bound variables:
      if $M \leadsto N_1$ and $M \leadsto N_2$ then $N_1$ and $N_2$ are
      $\alpha$-equivalent.\footnote{%
        We may also require a reduction strategy 
        to rename bound variables whenever necessary, and thus  
        $N_1$ is required to be as the same as $N_2$. But, in practice,
        there are \emph{nameless} representations of $\lambda$-terms, so renaming
        is not required. See \cite[Appendix C]{Barendregt1984a} for the de Bruijn
        index approach, or \cite{Chargueraud2012} for the locally nameless
        representation.}
  \end{enumerate}
\end{definition}
For example, we may start from the $\beta$-redex which does not contain
any $\beta$-redex, called the \emph{innermost $\beta$-redex}. Or, we start from
the $\beta$-redex which is not contained in any other $\beta$-redex, called the
\emph{outermost $\beta$-redex}. 
\begin{description}
  \item[the leftmost-outermost strategy] reduces the leftmost outermost
    $\beta$-redex in a $\lambda$-term first. For example, 
    \begin{align*}
      & 
      \underline{(\lambda x.\, (\lambda y.\, y)\,x)}\quad
      \underline{(\lambda x.\, (\lambda y.\, y\,y)\,x)}
      \\
      \onereduce &
      \underline{(\lambda y.\, y)}\quad
      \underline{(\lambda x.\, (\lambda y.\, y\,y)\, x)} \\
      \onereduce &
      \underline{(\lambda x.\, (\lambda y.\, y\,y))}\;
      \underline{\vphantom{(\lambda}x} \\
      \onereduce & (\lambda y.\, y\,y)
    \end{align*}
  \item[the leftmost-innermost strategy] reduces the leftmost innermost
    $\beta$-redex in a $\lambda$-term first. For example, 
    \begin{align*}
      & (\lambda x.\, \underline{(\lambda y.\,
        y)}\;\underline{\vphantom{(\lambda} x})\,
      (\lambda x.\, (\lambda y.\, y\, y)\,x) \\
      \onereduce & (\lambda x.\,x)\;
      (\lambda x.\, \underline{(\lambda y.\, y\,
        y)}\;\underline{\vphantom{(\lambda}x}) \\
      \onereduce & \underline{(\lambda x.\,x)}\;\underline{(\lambda x.\, x\,x)} \\
      \onereduce & (\lambda x.\, x\, x)
    \end{align*}
  \item[the rightmost-innermost strategy and the rightmost-outermost strategy]
    are defined similarly but they reduce $\lambda$-terms from right to left
    instead.
\end{description}
There are also strategies which does not reduce any $\beta$-redex in an
abstraction~$(\lambda x.\, M)$ including the so-called
\emph{call-by-value} and \emph{call-by-name} reduction strategies.

However, with different strategies a $\lambda$-term may have an infinitely long
reduction and a finite sequence of reductions at the same time. 
\begin{example} \label{ex:omega}
  Define the following terms
  \begin{align*}
    \Omega &\defeq (\lambda x.\, x\,x)(\lambda x.\,x\,x) \\
    \mathbf{K}_1 & \defeq \lambda x.\,(\lambda y.\, x).
  \end{align*}
  First of all, we observe that $\Omega$ has an infinite chain of reductions:
  \[
    \Omega \onereduce (x\;x)\subst{x}{\lambda x.\, x\,x} = \Omega 
    \onereduce\Omega \onereduce \dots 
  \]
  Then, the term $(\mathbf{K}_1\,z)\,\Omega$ has the following
  chain of reductions:
  \[
    (\mathbf{K}_1\,z)\,\Omega
    \onereduce 
    (\mathbf{K}_1\,z)\,\Omega
    \onereduce \dots
  \]
  if we always reduce the rightmost argument $\Omega$ first.
  However, $(\mathbf{K}_1\,z)\,\Omega$ also has a finite chain of reductions:
  \[
    (\mathbf{K}_1\,z)\,\Omega
    \onereduce (\lambda y. z)\,\Omega
    \onereduce z
  \]
  if we adopt the leftmost(-outermost) strategy.

\end{example}

\begin{definition}
  Suppose that $M$ is a $\lambda$-term. Then, 
  \begin{enumerate}[(a)]
    \item $M$ is a \emph{normal form} if $M$ contains no $\beta$-redex. That is,
      there exists no $\lambda$-term $N$ with~$M \onereduce N$;
    \item $M$ is called \emph{weakly normalising} if $M$ is normal or there
      exists a normal term $N$ a chain of $\beta$ reductions with
      \[
        M \onereduce M' \onereduce \dots \onereduce N. 
      \]
  \end{enumerate}
\end{definition}

\begin{example}
  Recall Example~\ref{ex:omega}. 
  \begin{enumerate}
    \item $\Omega$ does not have a normal form.
    \item $\mathbf{K}_1$ is normal and weakly normalising.
    \item $(\mathbf{K}_1 z) \Omega$ is weakly normalising.
  \end{enumerate}
\end{example}
As we have seen, different strategies may give different results, so it leads to
a natural question to ask: do different orders of reductions produce the same
normal form, if any? 

\subsection{Church-Rosser Theorem}
To answer the previous question, it suffices to prove the following theorem:
\begin{theorem}[Church-Rossser Theorem]
  Let $M \xrightarrow{\beta*} N$ denote that $M$ and $N$ are $\alpha$-equivalent
  or there exists a finite chain of $\beta$-reductions
  \[
    M \onereduce M_1 \onereduce \dots \onereduce N
  \]
  Then, given any two terms $N_1$ and $N_2$ with
  $M \reduce N_1$ and $M\reduce N_2$, there exists $L$ such that
  \[
    \xymatrix{
      & M \ar[rd]^{\beta*} \ar[ld]_{\beta*} \\
      N_1 \ar@{-->}[rd]_{\beta*} & & N_2 \ar@{-->}[ld]^{\beta*} \\
      & L
    }
  \]
\end{theorem}
\begin{proof}
  The complete proof can be found in~\cite[Chapter 4]{Barendregt1984}.
\end{proof}
\begin{corollary}[Uniqueness of normal forms]\label{coro:uniqueness-normal}
  Suppose that $N_1$ and $N_2$ are normal. Then, 
  \[
    \xymatrix{
      & M \ar[rd]^{\beta*} \ar[ld]_{\beta*} \\
      N_1 \ar@{}[r]|{\equiv_\alpha} & N & N_2 \ar@{}[l]|{\equiv_\alpha} \\
    }
  \]
  That is, $N_1$ and $N_2$ are $\alpha$-equivalent.
\end{corollary}
\subsection*{Exercise}
\todo[inline]{Evaluate some terms}
\begin{enumerate}
  \item Prove Corollary~\ref{coro:uniqueness-normal}.
  \item Read the paper~\cite[Section 7]{Sestoft2002} for more reduction
    strategies.
\end{enumerate}
\section{Programming in lambda calculus}
\subsection{Church numerals and arithmetic}
There is no \emph{built-in} natural number in lambda calculus. However, 
not only every natural number can be defined as a $\lambda$-term, but also 
operations, e.g.\ addition, multiplication, and even exponential, on natural
number can be defined. In fact, every computable function (on natural numbers)
is definable in lambda calculus. 

\begin{definition}[Church numerals]
  Define $f^1 \defeq f$ and $f^{n+1} \defeq f\,f^n$. Then, 
  \[
    \overline{0} \defeq \lambda f.\, (\lambda x.\, x)
    \quad
    \overline{1} \defeq \lambda f.\, (\lambda x.\, f x)
    \quad\text{and}\quad
    \overline{n} \defeq \lambda f.\, (\lambda x.\, f^{n} x)
  \] 
\end{definition}

\begin{definition}[Successor]
  Define
  \[
    \mathtt{succ} \defeq \lambda n.\, (\lambda f.\, (\lambda x.\, f(n f x)))
  \]
  Then,
  \[
    \mathtt{succ}\;\overline{n} \reduce \overline{n+1}.
  \]
  for any natural number~$n$.
\end{definition}
\begin{proof}
  The proof is left as an exercise to the reader.
\end{proof}
\begin{proposition}[Addition]
  Define a $\lambda$-term 
  \[
    \mathtt{add} \defeq \lambda n_1.\,\lambda n_2.\, \lambda f.\,\lambda x.\,
    (n_1 f)(n_2 fx)
  \]
  as the addition operation of Church numerals.
  Then, 
  \[
    \mathtt{Add}\;\overline{n}\;\overline{m}\;
    \reduce\;\overline{n + m}
  \]
\end{proposition}
\begin{example}
  Evaluate the following terms.
  \begin{enumerate}
    \item $\mathtt{add}\;\overline{0}\;\overline{1}
      \reduce \overline{1}$.
    \item $\mathtt{add}\;\overline{1}\;\overline{1}
      \reduce \overline{2}$.
    \item $\mathtt{add}\;(\mathtt{succ}\;\overline{0})\;\overline{1}$.
    \end{enumerate}
\end{example}
\begin{proposition}[Boolean values, conditional operator]
  Define 
  \[
    \mathtt{T} \defeq \lambda x.\,(\lambda y.\, x)
    \quad\text{and}\quad
    \mathtt{F} \defeq \lambda x.\,(\lambda y.\, y)
  \]
  and also the pairing of two $\lambda$-terms $M$ and $N$:
  \[
    [\,M, N\,] \defeq \lambda z.\, (z\,M)\,N
  \]
  Then, 
  \begin{align*}
    [\,M, N\,]\;\mathtt{T} \reduce M \\
    [\,M, N\,]\;\mathtt{F} \reduce N
  \end{align*}
\end{proposition}
\begin{proof}
  The proof is left as an exercise to the reader.
\end{proof}
\subsection{Some combinators and the fixed-point Combinator}
Here is a list of common combinators:
\begin{enumerate}
  \item $\omega \defeq \lambda x.\, x\,x$
  \item $\Omega \defeq (\lambda x.\, x\,x)\,(\lambda x.\,x\,x)
    = \omega\,\omega$
  \item $\mathbf{K}_1 \defeq \lambda x.\,(\lambda y.\,
    x) = \mathtt{T}$, the first projection.
  \item $\mathbf{K}_2 \defeq \lambda x.\,(\lambda y.\,
    y) = \mathtt{F}$, the second projection.
  \item $\mathbf{I} \defeq \lambda x.\, x$, known as the \emph{identity}.
  \item $\mathbf{S}\defeq\lambda f.\,\lambda g.\,\lambda x.\, 
    (f\,x)\,(g\,y)$.
\end{enumerate}
\begin{example}[Factorial, informally]

\end{example}
\begin{proposition}[Curry's fixed-point combinator]
  Define
  \[
    \mathbf{Y} \defeq
    \lambda f.\, (\lambda x.\, f\,(x\,x))\,(\lambda x.\,f\,(x\,x))
  \]
  Then, for every $\lambda$-term~$F$, we have
  \begin{align*}
    \mathbf{Y}F
    & \onereduce \underline{(\lambda x.\,F\,(x\,x))\,(\lambda x.\, F\,(x\,x))} \\
    & \onereduce F\,(\underline{(\lambda x.\,F\,(x\,x))\,(\lambda x.\,
      F\,(x\,x))})
  \end{align*}
  That is, the term $(\lambda x.\,F\,(x\,x))\,(\lambda x.\, F\,(x\,x))$
  reoccur as the argument of~$F$ in the last step.
\end{proposition}

\begin{proposition}[Turing's fixed-point combinator]
  Define 
  \[
    \Theta \defeq 
    (\lambda x.\,(\lambda f.\,(f\,(x\,x\,f))))\;
    (\lambda x.\,(\lambda f.\,(f\,(x\,x\,f))))
  \]
  Then, 
  \[
    \Theta F \reduce F (\Theta F)
  \]
\end{proposition}
\begin{proof}
  The proof is left as an exercise to the reader.
\end{proof}
\begin{example}[Factorial, formally]
\end{example}

In fact, every computable function (equivalently, recursive functions) on
natural numbers is definable in terms of $\lambda$-terms. Due to the time
constrains, we refer the reader to~\cite[Chapter 3]{Barendregt1984} for further
detail.

\subsection*{Exercise}
\begin{enumerate}
  \item Define the \emph{swap} operation, i.e\ a $\lambda$-term~$\mathbf{C}$
    such that
    \[
      ((\mathbf{C}\,M)\,N)\,P
      \reduce (M\,P)\,N
    \]
  \item Define a $\lambda$-term $\mathtt{sum}$ such that
    $\mathtt{sum}\;\overline{n} \reduce \overline{0 + 1 + 2 + \dots + n}$.
  \todo[inline]{give more examples}
\end{enumerate}
\bibliographystyle{plain}
\bibliography{library} 
\end{document}
