%! TEX root = lecture1_note.tex
\title{Lambda Calculus and Types}
\author[L.-T. Chen]{Chen, Liang-Ting\\
  \href{mailto:ltchen@hawaii.edu}{\texttt{ltchen@hawaii.edu}}}
\institute{Department of Information and Computer Sciences, University of Hawaii
at Manoa}
\begin{document}
\begin{frame}
\maketitle
\end{frame}

The aim of this course is to teach the practical part of untyped and typed
lambda calculus which is the formalisation of functional programming,
and unfortunately we have to omit the computability aspect due to time
constraints. Another aspect we will not discuss is the denotational semantic of
lambda calculus. It is one of the well-studied subject in theoretical computer
science but it requires a mathematical background.

\todo{historical remark}

For further details about lambda calculus, the reader is referred
to~\cite{Barendregt1984,Barendregt1992}. 

\section{Untyped lambda calculus}
We begin with an informal introduction to lambda calculus. Lambda calculus can
be viewed as a simplest programming language whose syntax only consists of
\begin{enumerate}[(a)]
  \item infinitely many variables $x, y, z, \ldots$, 
  \item function application $F(a)$, or just $F a$, and
  \item function abstraction $F(x) \defeq M$, or just $\lambda x.\, M$
    as an anonymous function, whose intuitive meaning is to define a function
    with a parameter~$x$.
\end{enumerate}
The only possible computation is the substitution for the parameter in the
function body by its argument, written as 
\[
  (\lambda x.\, M)\, N \leadsto M\subst{x}{N}
\]
and the computation is finished while there is no possible reduction, e.g.
\[
  (\lambda x.\, \lambda y.\, (x y) z) (\lambda x.\, x)
  \leadsto (\lambda y.\, (x y) z)\subst{x}{(\lambda x.\, x)}
  \leadsto \lambda y.\, (\lambda x.\, x) y z
  \leadsto \lambda y.\, (x\subst{x}{y}) z
  \leadsto \lambda y.\, y z
\]

\subsection{Syntax, alpha-conversion, beta-reduction}
\begin{definition}[Syntax]
  Let $V \defeq \{ x, y, z, \ldots \}$ be a countably infinite set of
  \emph{variables}.  The set $\Lambda = \Lambda_V$ of \emph{$\lambda$-terms} is
  defined inductively
  \begin{columns}
    \column{.3\textwidth}
    \begin{prooftree}
      \AXC{$x \in V$}
      \RightLabel{(variable)}
      \UIC{$x \in \Lambda$}
    \end{prooftree}
    \column{.3\textwidth}
    \begin{prooftree}
      \AXC{$M, N \in \Lambda$}
      \RightLabel{(application)}
      \UIC{$(M\, N) \in \Lambda$}
    \end{prooftree}
    \column{.3\textwidth}
    \begin{prooftree}
      \AXC{$M \in \Lambda, x \in V$}
      \RightLabel{(abstraction)}
      \UIC{$\lambda x.\, M \in \Lambda$}
    \end{prooftree}
  \end{columns}
  Equivalently, $\Lambda$ is the language generated by the following
  context-free grammar:
  \[
  \Lambda \longrightarrow V \mid (\Lambda\, \Lambda) \mid \lambda V.\, \Lambda
  \]
\end{definition}
Throughout this lecture, we assume that $V$ is the variable set for
$\lambda$-terms. 
\begin{definition}[Free variables, closed terms, and substitution]
  \begin{enumerate}[(a)]
    \item The free variable set $\FV\colon \Lambda \to V$ is a function from the
      set~$\Lambda$ of $\lambda$-terms to the variable set~$V$ defined
      inductively as follows:
      \begin{align*}
        \FV(x) & = \{ x \} \\
        \FV(M\, N) & = \FV(M) \cup \FV(N) \\
        \FV(\lambda x.\, M) & = \FV(M) - \{ x \}.
      \end{align*}
      That is, a variable $v$ of a $\lambda$-term~$M$ is \emph{free} if $v \in
      \FV(M)$, otherwise $v$ in a $\lambda$-term is
      \emph{bound}. The set of bound variable is denoted by~$\BV(M)$.
    \item A $\lambda$-term~$M$ is \emph{closed} or a
      \emph{combinator} if $\FV(M) = \emptyset$. That
      is, $M$ contains no free variable. Closed terms are also called
      \emph{combinators}.
    \item The \emph{(capture-avoidance) substitution} of $P$ for the free occurrences of $x$ is a
      partial function mapping a $\lambda$-term $M$ to another $\lambda$-term,
      denoted by $M\subst{x}{P}$, defined inductively as follows:
      \begin{align*}
        x\subst{x}{P} & = P \\
        y\subst{x}{P} & = y && \text{if $x \neq y$} \\
        (M\, N)\subst{x}{P} & = (M\subst{x}{P}\, N\subst{x}{P}) \\
        (\lambda x.\, M)\subst{x}{P} & = (\lambda x.\, M) \\
        (\lambda y.\, M)\subst{x}{P} & = (\lambda y.\, M\subst x P)
        && \text{if $x \neq y$, and $y \not\in \FV(P)$.}\\
      \end{align*}
  \end{enumerate}
\end{definition}

\begin{convention}
  We do \emph{NOT} distinguish two $\lambda$-terms if they only differ in the
  name of bound variables. For example, $(\lambda x.\, x)$ may be renamed to 
  $(\lambda y.\, y)$, and we consider them the same. The name of variable do not
  affect program behaviours but readability.
\end{convention}
\begin{definition}[$\alpha$-equivalence: renaming of bound variables]
  Whenever a variable $y$ does not occur freely in~$M$, we can rename the bound
  variable $x$ in~$\lambda x.\, M$, i.e.\ 
  \[
    (\lambda x.\, M) \equiv (\lambda y.\, M\subst{x}{y})
  \]
  if $y \not\in \FV(M)$. We also need to carry this identification through every
  subterm, so we add the following congruence rule
  \begin{columns}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{$M_1 \equiv M_2$}
      \UIC{$M_1\,N \equiv M_2\,N$}
    \end{prooftree}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{$N_1 \equiv N_2$}
      \UIC{$M\,N_1 \equiv M\,N_2$}
    \end{prooftree}
  \end{columns}
  and also the reflexivity, symmetry, and transitivity.
\end{definition}
\begin{definition}[$\beta$-conversion: one-step reduction]
  An application of this form $(\lambda x.\, M)\, N$ reduces to a
  $\lambda$-term~$M\subst{x}{N}$. Symbolically, we write 
  \[
    (\lambda x.\, M)\, N \xrightarrow{\beta} M'\subst{x}{N}
  \]
  if $M\equiv M'$ and $M\subst{x}{N}$ is defined.
  The conversion $\leadsto_\beta$ is called \emph{$\beta$-conversion} or
  sometime and the term $(\lambda x.\, M)\, N$ is
  called a \emph{$\beta$-redex}.
\end{definition}
\begin{definition}[$\beta$-conversion congruence]
  A reduction step can happen in a subterm inside a $\lambda$-term, so
  we add the following congruence rules:
  \begin{columns}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{$M_1 \xrightarrow{\beta} M_2$}
      \UIC{$M_1 \onereduce M_2$}
    \end{prooftree}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{$M_1 \onereduce M_2$}
      \UIC{$\lambda x.\, M_1 \onereduce \lambda x.\, M_2$}
    \end{prooftree}
  \end{columns}
  \begin{columns}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{$M_1 \onereduce M_2$}
      \UIC{$M_1 N \onereduce M_2 N$}
    \end{prooftree}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{$N_1\onereduce  N_2$}
      \UIC{$M N_1 \onereduce M N_2$}
    \end{prooftree}
  \end{columns}
  so that $\leadsto_{\beta1}$ is the least congruence containing $\leadsto_\beta$.
\end{definition}
\begin{definition}[$\beta$-reduction]
  We say that $M_1$ can be reduced to $M_2$
  if $M_1 \equiv M_2$ or there exists a finite sequence of $\beta$-conversion:
  \[
    M_1 \onereduce M' \onereduce \dots \onereduce M_2
  \]
  denoted by $M_1 \reduce M_2$. That is, $\reduce$ is the
  reflexive and transitive closure of~$\onereduce$.
\end{definition}
\subsection{Reduction strategies}
\subsubsection*{Call by what?}
\todo[inline]{Draw some examples from \cite{Sestoft2002}.}
\subsubsection*{Church-Rosser Theorem}
\begin{definition}
  Suppose that $M$ is a $\lambda$-term. Then, 
  \begin{enumerate}[(a)]
    \item $M$ is a \emph{$\beta$-normal form}, if there is no
      one-step $\beta$-reduction, i.e. $M \not\leadsto_{\beta1} N$ for any
      $\lambda$-term~$N$.
    \item $M$ is called \emph{weakly normalising} if there exists
      a normal term $N$ with $M \leadsto^*_{\beta} N$. 
    \item $M$ is \emph{strongly normalising} if there is no infinite sequence of
      (one-step) reductions 
      \[
        M \onereduce M_1 \onereduce \dots \onereduce \dots
      \]
  \end{enumerate}
\end{definition}
\begin{theorem}[Church-Rossser Theorem]
  \[
    \xymatrix{
      & M \ar[rd]^{\beta*} \ar[ld]_{\beta*} \\
      N_1 \ar@{-->}[rd]_{\beta*} & & N_2 \ar@{-->}[ld]^{\beta*} \\
      & \exists L
    }
  \]
\end{theorem}
\begin{corollary}[Uniqueness of normal forms]
  Suppose that $N_1$ and $N_2$ are normal. Then, 
  \[
    \xymatrix{
      & M \ar[rd]^{\beta*} \ar[ld]_{\beta*} \\
      N_1 \ar@{-->}[r]_{\equiv} \ar@{}[r]|\equiv & N & N_2 \ar@{}[l]|\equiv \\
    }
  \]
\end{corollary}
\subsection{Programming in lambda calculus}
\subsubsection*{Church numerals, Booleans, and pairing}
There is no \emph{built-in} natural number in lambda calculus. However, 
not only every natural number can be defined as a $\lambda$-term, but also 
operations, e.g.\ addition, multiplication, and even exponential, on natural
number can be defined. In fact, every computable function (on natural numbers)
is definable in lambda calculus. 

\begin{definition}[Church numerals]
  Define $f^1 \defeq f$ and $f^{n+1} \defeq f\,f^n$. Then, 
  \[
    \overline{0} \defeq \lambda f.\, \lambda x.\, x
    \quad
    \overline{1} \defeq \lambda f.\, \lambda x.\, f x
    \quad\text{and}\quad
    \overline{n} \defeq \lambda f.\, \lambda.\, f^{n} x
  \] 
\end{definition}

\begin{definition}[Successor]
  \[
    \lambda n.\, \lambda f.\, \lambda x.\, f(n f x)
  \]
\end{definition}
\begin{definition}[Addition]
  \[
    \lambda n_1.\,\lambda n_2.\, \lambda f.\,\lambda x.\, (n_1 f)(n_2 fx)
  \]
\end{definition}

\begin{definition}[Boolean values]
  \[
    \mathtt{T} \defeq \lambda x.\,\lambda y.\, x
    \quad\text{and}\quad
    \mathtt{F} \defeq \lambda x.\,\lambda y.\, y
  \]
\end{definition}
\subsubsection{Combinators}

\subsubsection*{Fixed-point combinator}

\subsection*{Exercise}
\begin{enumerate}
  \item Give an inductive definition of bound variable. That is, define a
    function $\BV\colon \Lambda \to V$ inductively
    such that $\BV(M)$ is exactly the set of bound variable in a
    $\lambda$-term~$M$.

\end{enumerate}

\bibliographystyle{plain}
\bibliography{library} 
\end{document}
